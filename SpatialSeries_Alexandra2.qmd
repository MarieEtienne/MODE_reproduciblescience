---
title: "SpatialSeries_Alexandra"
author: "Alexandra"
format: html
editor: visual
---

# II - Spatial series

Spatial relationships are multidirectional and multilateral. They are distinct, in this sense, from temporal relationships, which allow only sequential relationships along the past-present-future axis.

#2.1) Defining neighbours

#2.1.1) Characteristics of the relationships between spatial objects

Consider a surface ℜ. This surface can be divided into n mutually exclusive zones. Two adjacent zones are separated by a common boundary.

**Mathematical definition of spatial relationships :**

Spatial relationships $B$ are a subset of the Cartesian product $ℝ²× ℝ² = {(i, j) : i ∈ ℝ ², j ∈ ℝ²}$ of couples $(i, j)$ of spatial objects, i.e. all couples $(i, j)$ such that $i$ and $j$ are both spatial objects identified by their geographical coordinates, and such that $(i, j)$ is different from $(j,i)$. A spatial object cannot be linked to itself: $(i,i) ⊈ B$. Moreover, if $(i, j) ⊆ B$ and $(j,i) ⊆ B$ for all couples of spatial objects, the spatial relationships are said to be symmetrical (Tiefelsdorf 1998).

Figure 1 illustrates the codifying process of spatial relationships. This approach makes it possible to systematically transcribe the complexity of geographic space into a final set of data analysable by a computer.

![Figure 1 : Codifying spatial correlation (Tiefelsdorf, 1998)](C:/Users%5Calexa%5Cgit%5CMODE_reproduciblescience%5CSpatial%20autocorrelation_%20modelisation%5CFigure%201.png)

First, the study zone is divided into mutually exclusive areas. Each area contains a reference point (often its centroid). Then, the spatial relationships can be specified by a neighbourhood graph connecting the areas considered to be neighbouring, or by a matrix containing the geographical coordinates of the reference points. The third step consists in coding the graph in a neighbourhood matrix, or transforming the geographic coordinates into a distance matrix.

The neighborhood matrix measures the similarity between observations. A value greater than zero indicates that the observations are considered neighbors. For example, in the case of the binary matrix shown in figure 1 :

$$w_ij = 
\{1 if i and j are spatially linked to each other 
-
0 otherwise\}$$

**The "list of neighbours" object in R** Package *spdep* makes it possible to define the relationships between spatial objects. In R, the class of an object defines all its properties and how the statistician can use it. Neighbourhood relationships are recorded in an object of class nb. Assume n spatial observations and neighbours_nb the spatial object containing the associated neighbourhood relationships. neighbours_nb is a list of length n. Each element \[i\] of the list contains a vector with the index of the neighbours of the item indexed i. If \[i\] does not have neighbours, the list contains only 0. The list also contains a vector of characters corresponding to the attributes of each neighbourhood zone, as well as a logical value indicating whether the relationship is symmetrical (see Figure 2.2). The main information about the object neighbours_nb can be derived using the function: summary(neighbours_nb)

Let's load a few packages useful for analysis :

```{r}
#  Spatial series analysis : packages

#Libraries for spatial series analyses
library(spdep) #to extracted the neighbors is a spatial data
library(ade4)  #used for plotting spatial data
library(spatialreg) #used for spatial data modelling
library(gwrr)  #to run geographically weighted regression
#these two libraries (spdep and ade4 also provive function that make object compatibles between library)
```

Let's then begin the analysis of a dataset about plant and bird richness at the scale of Ille-et-Vilaine, "div35".

```{r}
#Spatial series analysis : dataset div35
#For a REGULAR configuration of points 

#      0 - Exporing the data set 
#investigate the data set of plant and bird richness at the scale of Ille-et-Vilaine
div35=read.table("C:/Users/alexa/OneDrive/Documents/3A ingé agro - M2 EFCE/ASA/Séries temporelles & spatiales/script and data for lecture-20230925/div35.txt", header=T, dec=",")
summary(div35)

#Plot the spatial distribution of the points
par(mfrow=c(1,1))
plot(div35[,3:4])

#This map is a map of Ille-et-Vilaine. We can point St-Malo in the North and Rennes in the center for example.

#The spatial configuration of the points is regular.

```

```{r}
#Application with R

library(rgdal) #To import MIF/MID files 
library(maptools) #To import files Shapefile 
library(tripack) #To calculate neighbours based on distance 
library(spdep) 

#Spatial File Import 
arr75 <- readOGR("~/ArmF.TAB", "ArmF") 

#Neighbours based on the concept of graph
 #The input file is a matrix with geographical coordinates 
#or an object from type SpatialPoints 
coords <- coordinates(arr75) IDs <- row.names(as(arr75,"data.frame")) 

#Delaunay Triangulation 
Sy4_nb <- tri2nb(coords, row.names=IDs) 
plot(arr75, border=’lightgray’) 
plot(Sy4_nb,coordinates(arr75),add=TRUE,col=’red’) 

#Sphere-of-influence based graph 
Sy5_nb <- graph2nb(soi.graph(Sy4_nb,coords),row.names=IDs) 
plot(arr75, border=’lightgray’) 
plot(Sy5_nb,coordinates(arr75),add=TRUE,col=’red’) 

#Gabriel Graph 
Sy6_nb <- graph2nb(gabrielneigh(coords), row.names=IDs) 
plot(arr75, border=’lightgray’) 
plot(Sy6_nb,coordinates(arr75),add=TRUE,col=’red’) 

#Relative neighbours graph 
Sy7_nb <- graph2nb(relativeneigh(coords), row.names=IDs) 
plot(arr75, border=’lightgray’) 
plot(Sy7_nb,coordinates(arr75),add=TRUE,col=’red’)

```

We can return to our previous dataset to investigate the configuration of the points :

```{r}
#Spatial series analysis : connexion between points
#For a regular configuration of points

#      1 - Examine the connection between points ====================
# To investigate the various criteria of connection between points we need to
# extract the coordinates in a separate object
xy=div35[,3:4]

#             A - If we choose that points are connected to their 4th nearest neighbors (the "rook connection") ----
div.knear4<-knearneigh(as.matrix(xy),4) #to extract the neighbour points
div.knear4

knn2nb(div.knear4) #knn2nb convert the object returned by the function knearneigh to a class nb (necessary for the subsequent function)
# The information printed corresponds to all the links that have been created compared to all those that could have been created (272)

knn2nb(div.knear4)  # transformation to get as many lists than points/observation
plot(knn2nb(div.knear4), xy, add=TRUE)


#             B - If we specify a queen type of connection with points connected to their 8th nearest neighbors (the "queen connection") ----
div.knear8<-knearneigh(as.matrix(xy),8)
div.knear8
knn2nb(div.knear8)

# Plotting the connection between points for each criterion
x11()
par(mfrow=c(1,2))

ade4::s.label(xy, ylim=c(min(div35[,4])-10000,max(div35[,4])+10000), xlim=c(min(div35[,3])-10000,max(div35[,3])+10000),  clabel=0.6, cpoint=1,neig=nb2neig(knn2nb(div.knear4)))
ade4::s.label(xy, ylim=c(min(div35[,4])-10000,max(div35[,4])+10000), xlim=c(min(div35[,3])-10000,max(div35[,3])+10000),  clabel=0.4, cpoint=1,neig=nb2neig(knn2nb(div.knear8)))
#Be careful, the distance between points is not always 10km !
```

**1.2 Neighborhood weights**

**1.2.1) From a list of neighbours to a weight matrix**

Once the neighbourhood graph has been defined and codified into a list of neighbours, the link between points $i$ and $j$ is transformed into the element $w_ij$ of the weight matrix$W$. The weight matrix $W$ is the "formal expression of spatialdependency between observations" (Anselin et al. 1988)

-   **Defining the weight matrix** Most commonly, the weight matrix is a binary contiguity matrix (see Figure ):

    ![](images/image-522223787.png){width="299"}

• The weight matrices can also take into account the distance between the geographical zones, as relationships becoming smaller with distance: 1 if d \< d0 - 0 otherwise, 1 d α , or e −αd with α an estimated or predetermined parameter. Using a maximum distance beyond which wi j = 0 makes it possible to limit the number of components with a value different from zero. As described in 2.1.2, when the size of the zones is heterogeneous, this method increases the risk of a considerable variability in the number of neighbours.

• Lastly, certain matrices take the strength of relations between the zones into account. For example, weight can be defined by b α i j d β i j with bi j a measure of the strength of relationships between zones i and j (which is not necessarily symmetrical), such as the percentage of common boundaries, the total population, the wealth and di j the distance between the zones. Some econometric studies are aimed at endogenising the weight matrices, but they are considered to be exogenous in most spatial econometric applications (Anselin 2013). In general, therefore, the neighbourhood weights must not be a function of the phenomenon which we are trying to explain.

![](images/image-497770688.png)



    ```{r}
    #Spatial series analysis : weight matrix

    # about the code : 
    # nb2neig(knn2nb()) transform the matrix to subsequently use it is ade4
    # neig= define the connection matrix between points

    #             Transform the list of the names of the neighbors to a 2 by 2 matrix of neighboors with "0" and "1" -----
    w2<-knn2nb(div.knear4)
    str(w2)                     # we have as much list as points
    nb2neig(knn2nb(div.knear4)) # these lists are transformed in a 2D matrix with 0 or 1.
    ```

##Correlation indices

```{r}
#Application

library(spdep) 
############################### 
# Data preparation ########### 
############################### 

#Extraction of list of neighbours (defined by default with Queen contiguity )
 iris75.nb <- poly2nb(iris75) 

#Creation of weight matrix 
iris75.lw <- nb2listw(iris75.nb,zero.policy=TRUE) 

#Calculation of standardised median income 
iris75.data <- as.data.frame(iris75) 
iris75.data$med_revenu_std <- scale(iris75.data$med_revenu) 

##################### 
# Moran’s diagram #
####################
moran.plot(iris75.data$med_revenu_std, iris75.lw, labels=FALSE, xlab=’observed distribution of standardised median income by IRIS’, ylab=’ Spatially lagged standardised median incomes’) 

###################### 
# Moran’s I test #
#################### 
moran.test(iris75.data$med_revenu_std,iris75.lw, zero.policy=TRUE, randomisation=FALSE) 

#Calculation of the range of Moran’s I 
moran.range <- function(lw) { 
wmat <- listw2mat(lw) 
return(range(eigen((wmat+t(wmat))/2)$values)) } 
moran.range(iris75.lw)

```
